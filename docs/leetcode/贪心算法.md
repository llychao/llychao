# 贪心算法

### 贪心算法的实现框架
```
从问题的某一初始解出发：
while (朝给定总目标前进一步)
{
利用可行的决策，求出可行解的一个解元素。
}
由所有解元素组合成问题的一个可行解；

```

### 题目1
```
> 738. 单调递增的数字
给定一个非负整数 N，找出小于或等于 N 的最大的整数，同时这个整数需要满足其各个位数上的数字是单调递增。

（当且仅当每个相邻位数上的数字 x 和 y 满足 x <= y 时，我们称这个整数是单调递增的。）

示例 1:

输入: N = 10
输出: 9
示例 2:

输入: N = 1234
输出: 1234
示例 3:

输入: N = 332
输出: 299
说明: N 是在 [0, 10^9] 范围内的一个整数。
```

```
贪心算法
题目要求小于等于N的最大单调递增的整数，那么拿一个两位的数字来举例。

例如：98，一旦出现strNum[i - 1] > strNum[i]的情况（非单调递增），首先想让strNum[i - 1]--，然后strNum[i]给为9，这样这个整数就是89，即小于98的最大的单调递增整数。

这一点如果想清楚了，这道题就好办了。

局部最优：遇到strNum[i - 1] > strNum[i]的情况，让strNum[i - 1]--，然后strNum[i]给为9，可以保证这两位变成最大单调递增整数。

全局最优：得到小于等于N的最大单调递增的整数。

但这里局部最优推出全局最优，还需要其他条件，即遍历顺序，和标记从哪一位开始统一改成9。

此时是从前向后遍历还是从后向前遍历呢？

这里其实还有一个贪心选择，对于“遇到strNum[i - 1] > strNum[i]的情况，让strNum[i - 1]--，然后strNum[i]给为9”的情况，这个strNum[i - 1]--的操作应该是越靠后越好。

因为这样才能让这个单调递增整数尽可能的大。例如：对于5486，第一位的5能不减一尽量不减一，因为这个减一对整体损失最大。

所以要从后向前遍历，遇到strNum[i - 1] > strNum[i]的情况，让strNum[i - 1]--，然后strNum[i]给为9，这样保证这个减一的操作尽可能在后面进行（即整数的尽可能小的位数上进行）。

确定了遍历顺序之后，那么此时局部最优就可以推出全局，找不出反例，试试贪心。

```

```python
    class Solution:
    def monotoneIncreasingDigits(self, N: int) -> int:
        # 贪心
        digtal = list(str(N))
        n = len(digtal)
        for i in range(n-1,0,-1):
            if digtal[i] < digtal[i-1]:
                digtal[i-1] = str(int(digtal[i-1])-1)
                digtal[i:] = ['9'] * (n-i)
        return int("".join(digtal))
```

### 题目2
```
> 分发饼干
假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。

对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] >= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。

 
示例 1:

输入: g = [1,2,3], s = [1,1]
输出: 1
解释: 
你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。
虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。
所以你应该输出1。
示例 2:

输入: g = [1,2], s = [1,2,3]
输出: 2
解释: 
你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。
你拥有的饼干数量和尺寸都足以让所有孩子满足。
所以你应该输出2.

```

```python
class Solution:
    def findContentChildren(self, g: List[int], s: List[int]) -> int:
        g.sort() #孩子数组
        s.sort() #饼干数组
        child = 0 #孩子 i
        cookie = 0 #饼干 j
        while child < len(g) and cookie < len(s):
            if g[child] <= s[cookie]: #能够满足一个孩子的胃口
                child += 1 #孩子饱了
            cookie += 1 #饼干吃了
        return child #返回被满足的孩子数

```