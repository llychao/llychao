# 问题列表

1. go读写锁和互斥锁的却别、使用场景? 读写锁为什么会比普通锁快?

```txt
互斥锁：
    互斥锁是并发程序对公共资源访问限制最常见的方式。
    在Go中，sync.Mutex 提供了互斥锁的实现。
    当一个goroutine获得了Mutex后，其他goroutine只能等待，除非该goroutine释放这个Mutex。

读写锁：
    读写锁则是对读写操作进行加锁。需要注意的是多个读操作之间不存在互斥关系，这样提高了对共享资源的访问效率。
    Go中读写锁由 sync.RWMutex 提供，RWMutex在读锁占用的情况下，会阻止写，但不阻止读。
    RWMutex在写锁占用情况下，会阻止任何其他goroutine（无论读和写）进来，整个锁相当于由该goroutine独占。

    1. RWMutex是单写多读锁，该锁可以加多个读锁或者一个写锁。
    2. 读锁占用的情况会阻止写，不会阻止读，多个goroutine可以同时获取读锁。
    3. 写锁会阻止其他gorotine不论读或者写进来，整个锁由写锁goroutine占用 与第一条共用示范代码
    4. 适用于读多写少的场景

```

2. goroutine协程和线程的区别？协程是怎么调度？

3. goroutine并发数控制？







